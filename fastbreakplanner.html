<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap">
        <style>
            /* Overall background */
            body {
                font-family: 'Roboto Condensed', sans-serif;
                color: #0b1392;
                background-color: #0b1392; /* Blue background */
                margin: 0;
                padding: 0;
            }
    
            /* Heading styles */
            h1 {
                font-family: 'Orbitron', sans-serif;
                color: #3eff2c;
                text-align: center;
                margin: 20px 0;
            }
    
            /* Section for download button */
            #downloadRunPlanButton {
                font-family: 'Bebas Neue', sans-serif;
                background-color: #0b1392;
                color: #fff;
                border: 2px solid #3eff2c;
                padding: 10px 20px;
                cursor: pointer;
                transition: background-color 0.3s ease, color 0.3s ease;
                border-radius: 5px;
                display: block;
                margin: 20px auto;
            }
    
            #downloadRunPlanButton:hover {
                background-color: #3eff2c;
                color: #0b1392;
            }
    
            /* General Table Styling */
            table {
                width: 100%;
                max-width: 800px;
                margin: auto;
                border-collapse: collapse;
                margin-top: 20px;
                box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5);
                text-align: center;
                white-space: nowrap;
                table-layout: auto;
            }

            thead {
                background-color: #3eff2c;
                font-family: 'Orbitron', sans-serif;
            }

            th {
                color: #0b1392;
                font-weight: bold;
                padding: 15px;
                font-size: 1.2em;
                max-width: 120px;
                white-space: normal;
                word-wrap: break-word;
                text-align: center;
            }

            tbody tr:nth-child(even) {
                background-color: #1b1f99;
            }

            tbody tr:nth-child(odd) {
                background-color: #11157d;
            }

            td {
                padding: 12px;
                font-size: 1.1em;
                font-weight: bold;
                color: #ffffff;
                font-family: 'Roboto Condensed', sans-serif;
                white-space: nowrap;
            }

            tbody tr:hover {
                background-color: #3eff2c;
                color: #0b1392;
                font-family: 'Bebas Neue', sans-serif;
            }
    
            /* Selected Player Tables - Fit Multiple in One Row */
            #selectedPlayersTable {
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
                justify-content: center;
            }
    
            /* Individual table styling for each day’s selected players */
            #selectedPlayersTable table {
                width: 200px; /* Smaller width to fit multiple tables per row */
                margin: 10px;
            }
    
            #selectedPlayersTable th, #selectedPlayersTable td {
                font-size: 14px;
                padding: 8px;
            }
    
            /* Games display section */
            #gamesDisplay {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
                margin-bottom: 20px;
            }
    
            /* Style for individual game match squares */
            .game-pair {
                background-color: #fff;
                color: #0b1392;
                border: 2px solid #3eff2c;
                padding: 10px;
                font-size: 14px;
                text-align: center;
                width: 80px; /* Smaller size for compact layout */
                border-radius: 5px;
            }

            button {
                font-family: 'Bebas Neue', sans-serif;
                background-color: #0b1392;
                color: #fff;
                border: 2px solid #3eff2c;
                padding: 10px 20px;
                cursor: pointer;
                transition: background-color 0.3s ease, color 0.3s ease;
                border-radius: 5px;
                margin: 10px 0;
            }

            button:hover {
                background-color: #3eff2c;
                color: #0b1392;
            }

            #daySelect {
                display: block;
                margin: 0 auto 20px auto;
                padding: 10px;
                font-size: 16px;
                border: 2px solid #3eff2c;
                background-color: #0b1392;
                color: #fff;
                font-family: 'Roboto Condensed', sans-serif;
                border-radius: 5px;
                width: 200px;
                text-align: center;
                cursor: pointer;
            }

            #daySelect option {
                color: #0b1392;
            }

            .section-title, #daySelect, #daySelect option {
                color: #3eff2c; /* Green highlight color for visibility */
            }

            .section-title {
                text-align: center;
            }

            /* Center the file upload container */
            .file-upload-container {
                display: flex;
                justify-content: center;
                gap: 10px;
                margin: 20px 0;
            }

            /* Style the file input */
            #csvFileInput {
                padding: 10px;
                font-family: 'Bebas Neue', sans-serif;
                background-color: #0b1392;
                color: #fff;
                border: 2px solid #3eff2c;
                border-radius: 5px;
                cursor: pointer;
            }

            /* Style the file input button */
            #csvFileInput::-webkit-file-upload-button {
                background: #0b1392;
                color: #fff;
                border: none;
                font-family: 'Bebas Neue', sans-serif;
                padding: 10px 15px;
                cursor: pointer;
                border-radius: 5px;
                transition: background-color 0.3s ease;
            }

            #csvFileInput::-webkit-file-upload-button:hover {
                background: #3eff2c;
                color: #0b1392;
            }

            /* Center the "Sort by Combined Stats" button */
            .centered-button {
                display: flex;
                justify-content: center;
                margin-top: 10px;
            }

            /* Style for "Sort by Combined Stats" button */
            #combinedStatsButton {
                font-family: 'Bebas Neue', sans-serif;
                background-color: #0b1392;
                color: #fff;
                border: 2px solid #3eff2c;
                padding: 10px 20px;
                cursor: pointer;
                transition: background-color 0.3s ease;
                border-radius: 5px;
            }

            #combinedStatsButton:hover {
                background-color: #3eff2c;
                color: #0b1392;
            }

            /* Main Table Border */
            #csvTable {
                border: 2px solid #3eff2c;
                border-radius: 8px;
                overflow: hidden;
            }

            @media (max-width: 768px) {
                table {
                    width: auto;
                    max-width: none;
                }
                th, td {
                    padding: 8px;
                    font-size: 12px;
                }
            }

            @media (max-width: 480px) {
                th, td {
                    padding: 6px;
                    font-size: 10px;
                }
                table {
                    font-size: 0.6em;
                }
            }

            /* Green Header Styling for allThresholdsDisplay and selectedPlayersTable */
            #allThresholdsDisplay th, #selectedPlayersTable th {
                background-color: #3eff2c;
                color: #0b1392;
                font-weight: bold;
            }

            /* Remove hover effect on rows in allThresholdsDisplay table */
            #allThresholdsDisplay tbody tr:hover {
                background-color: initial;
                color: initial;
                font-family: 'Roboto Condensed', sans-serif;
            }

            #allThresholdsDisplay {
                max-width: 100%; /* Ensure it doesn’t exceed page width */
                margin: 0 auto;
                padding: 10px;
            }

            #allThresholdsDisplay table {
                width: 95%; /* Ensure table does not extend beyond page bounds */
                border-collapse: collapse;
                font-size: 0.9em; /* Smaller font for compact layout */
                margin: 0 auto; /* Center the table */
            }

            #allThresholdsDisplay th, #allThresholdsDisplay td {
                padding: 8px; /* Adjust padding */
                text-align: center;
                white-space: nowrap;
            }

            /* Style for injured players in csvTable */
            #csvTable .injured-player td {
                background-color: #ff4d4d; /* Red background for injured players */
                color: #ffffff; /* White text for contrast */
            }

            .upload-info {
                font-family: 'Roboto Condensed', sans-serif;
                font-size: 0.9em;
                color: #ffffff;
                background-color: #0b1392;
                padding: 10px;
                border-radius: 5px;
                margin-bottom: 10px;
                text-align: center;
            }

            .upload-info a {
                color: #3eff2c;
                text-decoration: underline;
            }

            /* Donate button styling */
            #donate-button {
                display: inline-block;
                color: #0b1392;
                background-color: #3eff2c;
                font-size: 1.2em;
                padding: 10px 20px;
                margin-bottom: 15px;
                text-decoration: none;
                font-family: 'Roboto Condensed', sans-serif;
                font-weight: bold;
                border-radius: 5px;
                transition: background-color 0.3s, color 0.3s;
            }

            #donate-button:hover {
                background-color: #ffffff;
                color: #0b1392;
            }

            /* Center the Optimize Lineup button */
            .optimize-lineup-container {
                display: flex;
                justify-content: center;
                margin: 20px 0;
            }

            /* Style for the Optimize Lineup button */
            .optimize-lineup-button {
                font-family: 'Bebas Neue', sans-serif;
                font-size: 24px; /* Larger font size */
                background-color: #0b1392; /* Dark blue background */
                color: #fff; /* White text */
                border: 3px solid #3eff2c; /* Green border */
                padding: 15px 30px; /* Larger padding */
                cursor: pointer;
                transition: background-color 0.3s ease, color 0.3s ease;
                border-radius: 10px; /* Rounded corners */
            }

            /* Hover effect for the button */
            .optimize-lineup-button:hover {
                background-color: #3eff2c; /* Green background */
                color: #0b1392; /* Dark blue text */
            }

            #loadingCollection, #loadingOptimization {
                font-family: 'Roboto Condensed', sans-serif;
                font-size: 20px;
                font-weight: bold;
                color: #3eff2c;
                background-color: #0b1392;
                padding: 10px;
                border-radius: 5px;
                width: 100%;
            }


        </style>
    
    <title>Fast Break Projections</title>
</head>
<body>

<h1>Fast Break Run Planner</h1>



<!-- Section to display all days and their thresholds in a table format -->
<h2 class="section-title">NBA Fast Break Run 4</h2>

<div id="premiumInfo" style="text-align: center; margin-top: 20px;">
    <p style="color: white; font-size: 20px; margin-bottom: 10px;">
        Purchase premium access for just $15 a run to unlock the "Optimize Lineup" feature that optimizes your available players across the run for maximum wins!
    </p>
    <button onclick="purchasePremium()" style="background-color: #3eff2c; color: #0b1392; font-family: 'Bebas Neue'; padding: 10px 20px; border: none; border-radius: 5px; font-size: 20px; margin-bottom: 20px;">
        Purchase Premium
    </button>
</div>

<div id="loginContainer" style="text-align: center; margin-top: 20px;">
    <p style="color: white; font-size: 18px;">Enter your access code to unlock premium features:</p>
    <input id="accessCodeInput" type="password" placeholder="Enter access code" style="padding: 10px; font-size: 16px;">
    <button onclick="verifyAccessCode()" style="background-color: #3eff2c; color: #0b1392; font-family: 'Bebas Neue'; padding: 10px 20px; border: none; border-radius: 5px; font-size: 20px;">
        Submit
    </button>
    <p id="loginError" style="color: red; display: none;">Incorrect access code. Please try again or contact support.</p>
</div>


<!-- Donate button -->
<div style="text-align: center;">
    <a id="donate-button" href="https://buymeacoffee.com/stats2cash" target="_blank">Donate if you Enjoy!</a>
</div>

<div style="text-align: center;">
    <a id="donate-button" href="index.html">Back to Top Possible Lineup</a>
</div>

<div id="allThresholdsDisplay" style="margin-bottom: 20px;"></div>

<div id="selectedPlayersTable" style="margin-top: 20px;">
    <h3>Selected Players for Each Day</h3>
    <table border="1" style="width: 100%;">
        <thead>
            <tr id="daysHeaderRow"></tr>
        </thead>
        <tbody id="playersBodyRow"></tbody>
        <tfoot>
            <tr id="clearButtonsRow"></tr>
        </tfoot>
    </table>
</div>

<button id="downloadRunPlanButton" style="display: none;" onclick="downloadRunPlan()">Download Run Plan</button>

<div id="loadingOptimization" style="display: none; text-align: center; color: white; font-size: 18px; margin-top: 20px;">
    Loading Optimized Lineups...
</div>

<!-- Section to display NBA games for the selected day -->
<h2 class="section-title">NBA Games for Selected Day</h2>
<div id="gamesDisplay" style="margin-bottom: 20px;"></div>


<!-- Dropdown to select the day -->
<label for="daySelect">Select Day:</label>
<select id="daySelect" onchange="updateTableForSelectedDay()">
    <option value="1">Day 1</option>
    <option value="2">Day 2</option>
    <option value="3">Day 3</option>
    <option value="4">Day 4</option>
    <option value="5">Day 5</option>
    <option value="6">Day 6</option>
    <option value="7">Day 7</option>
    <option value="8">Day 8</option>
    <option value="9">Day 9</option>
    <option value="10">Day 10</option>
    <option value="11">Day 11</option>
    <!-- <option value="12">Day 12</option> -->
</select>



<!-- Section to display the stat thresholds for the selected day -->
<div id="thresholdDisplay"></div>

<div class="upload-info">
    Upload your OTM Moments Page CSV file here. This can be found at 
    <a href="https://www.otmnft.com/nbatopshot/collection/moments" target="_blank">https://www.otmnft.com/nbatopshot/collection/moments</a>
</div>

<!-- File upload input for Top Shot Moments -->
<div class="file-upload-container">
    <input type="file" id="csvFileInput" accept=".csv" />
    <button onclick="processFiles()">Upload</button>
</div>

<div class="optimize-lineup-container" style="display: none;">
    <button class="optimize-lineup-button" onclick="optimizeLineup()">Optimize Lineup</button>
</div>

<div class="centered-button">
    <button id="combinedStatsButton" style="display: none;">Sort by Combined Stats</button>
</div>

<div id="loadingCollection" style="display: none; text-align: center; color: white; font-size: 18px; margin-top: 20px;">
    Loading Collection...
</div>


<!-- Table to display processed data -->
<table id="csvTable" border="1">
    <thead>
        <tr id="tableHeaders"></tr>
    </thead>
    <tbody></tbody>
</table>

<style>
    .injured-player {
        background-color: red;
        color: white;
    }
</style>

<script>


    function purchasePremium() {
        window.open("https://buymeacoffee.com/stats2cash/e/336546", "_blank"); // Opens the link in a new tab
    }


    let userTriggeredSort = false;


    // Initialize playerUsages to keep track of remaining uses for each player globally
    let playerUsages = {};

    function initializePlayerUsages() {
        window.filteredData.forEach(player => {
            playerUsages[player.playerName] = player.uses;
        });
    }


const statMapping = {
    "Points": "points",
    "Rebounds": "rebounds",
    "Assists": "assists",
    "Steals": "steals",
    "Blocks": "blocks",
    "Turnovers": "turnovers",
    "Field Goals Made": "fieldGoalsMade",
    "Field Goals Attempted": "fieldGoalsAttempted",
    "3s": "threePointMade",
    "3s Attempted": "threePointAttempts",
    "Free Throws Made": "freeThrowsMade",
    "Free Throws Attempted": "freeThrowsAttempted",
    "Offensive Rebounds": "offensiveRebounds",
    "Defensive Rebounds": "defensiveRebounds",
    "Points In The Paint": "pitp",
    "Plus Minus": "plusMinus"
};


const rarityOrder = ['Legendary', 'Rare', 'Anthology', 'Common', 'Fandom'];
const usageMapping = {
    'Common': 1,
    'Fandom': 1,
    'Anthology': 2,
    'Rare': 2,
    'Legendary': 4
};
const rosterUrl = "https://script.google.com/macros/s/AKfycby0kzAojuJs1UNrcHrVVS3nxa4_kKNwyaiFhyxElFxeM4i1kCHsTRUcywfpdVpZVpidhA/exec";
const projectionsUrl = "https://script.google.com/macros/s/AKfycbzHbTrH2clErBUnjF9CJfPRhurzreynw4eDtxV4gTil4MRZirUom5M5J3u8tZGsdW4A/exec";
const thresholdsUrl = "https://script.google.com/macros/s/AKfycbxz8Sl8qXwwfTnD2vtKUpwYrbYEc__JaZlqSgOFNFpJsYoTErwJCISP84D_OnvBDoiC/exec";
const nbaGamesUrl = "https://script.google.com/macros/s/AKfycbzGgkvUeRpFL9L7Jvzl_xN1k7j2V0fFByDMPJNiidCdbdBlInw0zRWrMF-XEeIJT5z9/exec";

// Data Arrays
let activeRoster = [];
let projections = [];
let thresholds = {};


function isRunPlanComplete() {
    for (let day = 1; day <= 11; day++) {
        if (!selectedPlayers[day] || selectedPlayers[day].length < 5) {
            return false; // If any day has fewer than 5 players, the plan isn't complete
        }
    }
    return true; // All days have 5 players
}

// Fetch Functions
async function fetchThresholdsData() {
    try {
        const response = await fetch(thresholdsUrl);
        thresholds = await response.json();
        console.log("Fetched thresholds:", thresholds); // Confirming the structure
        displayAllThresholds();
        updateTableForSelectedDay(); // Default to Day 1
        return thresholds; // Return thresholds
    } catch (error) {
        console.error("Error fetching thresholds data:", error);
        return null; // Return null in case of error
    }
}

function getMappedKey(stat) {
    return statMapping[stat] || stat;
}


async function fetchRosterData() {
    try {
        const response = await fetch(rosterUrl);
        activeRoster = (await response.json()).map(entry => [entry.playerName, entry.nameFix]);
    } catch (error) {
        console.error("Error fetching roster data:", error);
    }
}

async function fetchProjectionsData() {
    try {
        const response = await fetch(projectionsUrl);
        projections = (await response.json()).map(row => ({
            fixedPlayerName: row.fixedPlayerName,
            playerName: row.playerName,
            team: row.team,
            minutes: row.minutes,
            points: row.points,
            rebounds: row.rebounds,
            assists: row.assists,
            steals: row.steals,
            blocks: row.blocks,
            turnovers: row.turnovers,
            "assists-turnovers": row.assists - row.turnovers,
            fieldGoalsMade: row.fieldGoalsMade,
            fieldGoalsAttempted: row.fieldGoalsAttempted,
            fieldGoalPercentage: row.fieldGoalPercentage,
            threePointMade: row.threePointMade,
            threePointAttempts: row.threePointAttempts,
            threePointPercentage: row.threePointPercentage,
            freeThrowsMade: row.freeThrowsMade,
            freeThrowsAttempted: row.freeThrowsAttempted,
            freeThrowPercentage: row.freeThrowPercentage,
            offensiveRebounds: row.offensiveRebounds,
            defensiveRebounds: row.defensiveRebounds,
            injuries: row.injuries,
            plusMinus: row.plusMinus,
            pitp: row.pitp
        }));

        // Store the projections in localStorage
        localStorage.setItem("projections", JSON.stringify(projections));
        console.log("Fetched and saved projections to localStorage:", projections);
        
    } catch (error) {
        console.error("Error fetching projections data:", error);
    }
}

// Function to fetch NBA games data
async function fetchNBAGamesData() {
    try {
        const response = await fetch(nbaGamesUrl);
        const gamesData = await response.json();
        return gamesData;
    } catch (error) {
        console.error("Error fetching NBA games data:", error);
        return {};
    }
}

let defaultSortApplied = false;

// Display Functions

async function displayNBAGames(gamesData, selectedDay = 1) {
    const dayKey = `Day ${selectedDay}`;
    const games = gamesData[dayKey] || [];
    const gameDisplayContainer = document.getElementById("gamesDisplay");

    if (!games || games.length === 0) {
        gameDisplayContainer.innerHTML = "<p>No games scheduled for this day.</p>";
        return;
    }

    gameDisplayContainer.innerHTML = ""; // Clear existing games

    // Create rows of games
    for (let i = 0; i < games.length; i += 2) {
        const team1 = games[i];
        const team2 = games[i + 1] || ""; // Handle odd number of teams

        const gamePairDiv = document.createElement("div");
        gamePairDiv.classList.add("game-pair");

        // Team 1 image and name
        if (team1) {
            const team1Div = document.createElement("div");
            team1Div.classList.add("team");

            const team1Img = document.createElement("img");
            team1Img.src = `Team Images/${team1}.png`;
            team1Img.alt = team1;
            team1Img.classList.add("team-image");

            const team1Name = document.createElement("span");
            team1Name.textContent = team1;

            team1Div.appendChild(team1Img);
            team1Div.appendChild(team1Name);

            gamePairDiv.appendChild(team1Div);
        }

        // Team 2 image and name
        if (team2) {
            const team2Div = document.createElement("div");
            team2Div.classList.add("team");

            const team2Img = document.createElement("img");
            team2Img.src = `Team Images/${team2}.png`;
            team2Img.alt = team2;
            team2Img.classList.add("team-image");

            const team2Name = document.createElement("span");
            team2Name.textContent = team2;

            team2Div.appendChild(team2Img);
            team2Div.appendChild(team2Name);

            gamePairDiv.appendChild(team2Div);
        }

        // Append the paired teams to the game display container
        gameDisplayContainer.appendChild(gamePairDiv);
    }
}




document.getElementById("daySelect").onchange = async (event) => {
    const selectedDay = event.target.value;
    const gamesData = await fetchNBAGamesData(); // Fetch NBA games data
    defaultSortApplied = false; // Reset for the new day selection
    await displayNBAGames(gamesData, selectedDay); // Load NBA games for the selected day
    updateTableForSelectedDay(window.filteredData); // Load data for the newly selected day
};

let selectedPlayers = {}; // Track selected players for each day

// Initialize table headers for Days 1 through 12 with clear buttons
function initializeDaysHeaders() {
    const headerRow = document.getElementById("daysHeaderRow");
    const clearButtonsRow = document.getElementById("clearButtonsRow");

    headerRow.innerHTML = ""; // Clear any existing headers
    clearButtonsRow.innerHTML = ""; // Clear any existing clear buttons

    for (let i = 1; i <= 11; i++) {
        // Add day headers
        const th = document.createElement("th");
        th.textContent = `Day ${i}`;
        headerRow.appendChild(th);

        // Add "Clear Lineup" buttons
        const clearButtonCell = document.createElement("td");
        const clearButton = document.createElement("button");
        clearButton.textContent = "Clear Lineup";
        clearButton.onclick = () => clearDayLineup(i); // Clear only the specific day
        clearButtonCell.appendChild(clearButton);
        clearButtonsRow.appendChild(clearButtonCell);
    }
}

// Update the function to clear a specific day’s lineup
function clearDayLineup(day) {
    // Check if there are players selected for the given day
    if (selectedPlayers[day]) {
        // Loop through each player in the day's lineup and reset their usage count
        selectedPlayers[day].forEach(playerName => {
            if (playerUsages[playerName] !== undefined) {
                playerUsages[playerName]++; // Reset the usage count
            }
        });

        // Clear the selected players for that day
        selectedPlayers[day] = [];
    }

    // Update the display after clearing
    updateSelectedPlayersDisplay();

    updateTableForSelectedDay(window.filteredData, day);
}

function downloadRunPlan() {
    const headers = ["Player", "Day 1", "Day 2", "Day 3", "Day 4", "Day 5", "Day 6", "Day 7", "Day 8", "Day 9", "Day 10", "Day 11", "Day 12"];
    const rows = [
        ["Player 1"],
        ["Player 2"],
        ["Player 3"],
        ["Player 4"],
        ["Player 5"]
    ];

    // Populate rows with player selections per day
    for (let day = 1; day <= 11; day++) {
        selectedPlayers[day].forEach((playerName, index) => {
            rows[index].push(playerName);
        });
    }

    // Add headers to CSV content
    let csvContent = "data:text/csv;charset=utf-8," + headers.join(",") + "\n";

    // Append each row of player data
    csvContent += rows.map(row => row.join(",")).join("\n");

    // Create a downloadable link
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "Run_Plan.csv");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}



function updateSelectedPlayersDisplay(optimizedPlayers = null) {
    const selectedPlayersContainer = document.getElementById("selectedPlayersTable");
    if (!selectedPlayersContainer) {
        console.error("Container element 'selectedPlayersTable' not found in the HTML.");
        return;
    }

    selectedPlayersContainer.innerHTML = ""; // Clear previous content

    // Use optimizedPlayers if provided, otherwise fallback to user-selected lineups
    const playersToDisplay = optimizedPlayers || selectedPlayers;

    // Style the container to use flexbox for aligning tables in a row
    selectedPlayersContainer.style.display = "flex";
    selectedPlayersContainer.style.flexWrap = "wrap";
    selectedPlayersContainer.style.gap = "20px";

    for (let day = 1; day <= 11; day++) {
        const dayKey = `Day ${day}`;
        const thresholdData = thresholds[dayKey];
        const statKeys = Object.keys(thresholdData).map(stat => statMapping[stat] || stat.toLowerCase().replace(/\s/g, ""));
        const statNames = Object.keys(thresholdData);
        const dayLineup = playersToDisplay[day] || [];

        // Create a container for each day's table
        const daySection = document.createElement("div");
        daySection.style.marginBottom = "20px";

        // Create table structure with minimal width
        const table = document.createElement("table");
        table.style.borderCollapse = "collapse";
        table.style.margin = "0 auto"; // Center the table in the day section
        table.border = "1"; // Add border to the table

        // Header for Day and Stats
        const headerRow = document.createElement("tr");
        const dayHeader = document.createElement("th");
        dayHeader.colSpan = statNames.length + 1;
        dayHeader.textContent = `Day ${day}`;
        headerRow.appendChild(dayHeader);
        table.appendChild(headerRow);

        // Stat headers
        const statHeaderRow = document.createElement("tr");
        statHeaderRow.appendChild(document.createElement("th")); // Placeholder for "Player" column
        statNames.forEach(statName => {
            const statHeader = document.createElement("th");
            statHeader.textContent = statName;
            statHeaderRow.appendChild(statHeader);
        });
        table.appendChild(statHeaderRow);

        // Rows for each selected player
        let currentTotals = Array(statNames.length).fill(0);
        dayLineup.forEach(playerName => {
            const row = document.createElement("tr");
            const playerCell = document.createElement("td");
            playerCell.textContent = playerName;
            row.appendChild(playerCell);

            // Add player's stats for each threshold
            const playerProjection = projections.find(proj => proj.fixedPlayerName === playerName);
            statKeys.forEach((statKey, index) => {
                const statCell = document.createElement("td");
                const statValue = playerProjection ? parseFloat(playerProjection[statKey]) || 0 : 0;
                statCell.textContent = statValue.toFixed(2);
                statCell.style.border = "1px solid black"; // Add cell borders
                row.appendChild(statCell);

                // Add to current totals
                currentTotals[index] += statValue;
            });

            table.appendChild(row);
        });

        // Row for "Stats Needed" (thresholds)
        const thresholdRow = document.createElement("tr");
        const thresholdLabelCell = document.createElement("td");
        thresholdLabelCell.textContent = "Stats Needed:";
        thresholdRow.appendChild(thresholdLabelCell);

        statNames.forEach(statName => {
            const thresholdCell = document.createElement("td");
            thresholdCell.textContent = thresholdData[statName];
            thresholdCell.style.border = "1px solid black"; // Add cell borders
            thresholdRow.appendChild(thresholdCell);
        });
        table.appendChild(thresholdRow);

        // Row for "Current Total"
        const totalRow = document.createElement("tr");
        const totalLabelCell = document.createElement("td");
        totalLabelCell.textContent = "Current Total:";
        totalRow.appendChild(totalLabelCell);

        currentTotals.forEach((total, index) => {
            const totalCell = document.createElement("td");
            totalCell.textContent = total.toFixed(2);
            // Apply green background if total meets the threshold
            if (total >= thresholdData[statNames[index]]) {
                totalCell.style.backgroundColor = "green";
                totalCell.style.color = "white";
            }
            totalCell.style.border = "1px solid black"; // Add cell borders
            totalRow.appendChild(totalCell);
        });
        table.appendChild(totalRow);

        // Add the table and clear button for each day
        daySection.appendChild(table);
        const clearButton = document.createElement("button");
        clearButton.textContent = "Clear Lineup";
        clearButton.onclick = () => clearDayLineup(day);
        daySection.appendChild(clearButton);

        // Append day section to the main container
        selectedPlayersContainer.appendChild(daySection);

        // Display or hide the "Download Run Plan" button based on completeness
        const downloadButton = document.getElementById("downloadRunPlanButton");
        if (isRunPlanComplete()) {
            downloadButton.style.display = "block";
        } else {
            downloadButton.style.display = "none";
        }
    }
}

const ACCESS_CODE = 'Q9LIFBP77'; // Replace with your actual access code

function verifyAccessCode() {
    const enteredCode = document.getElementById('accessCodeInput').value.trim();

    if (enteredCode === ACCESS_CODE) {
        localStorage.setItem('premiumUser', 'true'); // Save premium status locally
        alert('Access granted! Premium features unlocked.');
        updateOptimizeButtonDisplay();
        document.getElementById('loginContainer').style.display = 'none';
    } else {
        document.getElementById('loginError').style.display = 'block';
    }
}

function isPremiumUser() {
    return localStorage.getItem('premiumUser') === 'true';
}

function updateOptimizeButtonDisplay() {
    const optimizeButtonContainer = document.querySelector('.optimize-lineup-container');
    const loginContainer = document.getElementById('loginContainer');

    if (isPremiumUser()) {
        optimizeButtonContainer.style.display = 'flex';
        loginContainer.style.display = 'none';
    } else {
        optimizeButtonContainer.style.display = 'none';
        loginContainer.style.display = 'block';
    }
}

window.onload = function() {
    updateOptimizeButtonDisplay();
};


function calculateFallbackScore(totalStats, thresholds) {
    let score = 0;

    Object.keys(thresholds).forEach(stat => {
        const statKey = statMapping[stat] || stat.toLowerCase().replace(/\s/g, "");
        const statValue = totalStats[statKey] || 0;
        const thresholdValue = thresholds[stat] || 0;

        if (statValue >= thresholdValue) {
            // Award points for exceeding the threshold
            score += statValue - thresholdValue;
        } else {
            // Penalize for falling short of the threshold
            score -= (thresholdValue - statValue);
        }
    });

    return score;
}




function addPlayerToDay(day, playerName) {
    if (!selectedPlayers[day]) {
        selectedPlayers[day] = [];
    }

    // Check if player can be added: limit to 5, no duplicates, and usage limit is not exceeded
    if (selectedPlayers[day].length < 5 && !selectedPlayers[day].includes(playerName) && playerUsages[playerName] > 0) {
        selectedPlayers[day].push(playerName);
        playerUsages[playerName]--; // Decrement the remaining usage count

        // Update only the specific player's usage cell in the table
        const playerRow = document.querySelector(`#csvTable tbody tr[data-player="${playerName}"]`);
        if (playerRow) {
            const usageCell = playerRow.querySelector(".usage-cell");
            if (usageCell) {
                usageCell.textContent = playerUsages[playerName]; // Update the usage display
            }
        }

        updateSelectedPlayersDisplay(); // Refresh the display for all selected players
    } else if (selectedPlayers[day].includes(playerName)) {
        alert(`${playerName} is already selected for Day ${day}.`);
    } else if (playerUsages[playerName] <= 0) {
        alert(`${playerName} has no remaining uses.`);
    }
}



async function updateTableForSelectedDay(data = window.filteredData) {
    if (!data) {
        console.error("No data available for table update.");
        return;
    }

    const selectedDay = document.getElementById("daySelect").value;
    updateSelectedPlayersDisplay(); // Display selected players for all days

    const dayKey = `Day ${selectedDay}`;
    const thresholdData = thresholds[dayKey];

    if (!thresholdData) {
        document.getElementById("thresholdDisplay").innerText = "No thresholds available for this day.";
        return;
    }

    // Fetch NBA games for the selected day to get the list of teams playing
    const gamesData = await fetchNBAGamesData();
    const teamsPlayingToday = gamesData[dayKey] || [];

    // Display threshold information for the selected day
    document.getElementById("thresholdDisplay").innerHTML = `<h3>Thresholds for ${dayKey}</h3>` +
        Object.entries(thresholdData).map(([stat, value]) => `<p>${stat}: ${value}</p>`).join("");

    // Only auto-sort by primary stat if no user-triggered sort is in effect
    if (!userTriggeredSort) {
        const primaryStat = Object.keys(thresholdData)[0];
        const primaryStatKey = statMapping[primaryStat] || primaryStat.toLowerCase().replace(/\s/g, "");

        window.filteredData = data.sort((a, b) => {
            const playerProjA = projections.find(proj => proj.fixedPlayerName === a.playerName);
            const playerProjB = projections.find(proj => proj.fixedPlayerName === b.playerName);

            const valueA = playerProjA ? parseFloat(playerProjA[primaryStatKey]) || 0 : 0;
            const valueB = playerProjB ? parseFloat(playerProjB[primaryStatKey]) || 0 : 0;

            return valueB - valueA; // Descending order by default
        });

        console.log("Auto-sorted data for primary stat:", primaryStatKey, window.filteredData);
    }

    // Prepare headers: always-visible columns + relevant stats for the day
    const headers = [
        { name: "Player Name", key: "playerName" },
        { name: "Highest Tier", key: "tier" },
        { name: "Number of Uses", key: "uses" },
        { name: "Team", key: "team" },
        { name: "Minutes", key: "minutes" },
        { name: "Injuries", key: "injuries" } // Ensure injuries is correctly displayed
    ];

    // Add dynamic columns based on the day’s stats
    Object.keys(thresholdData).forEach(stat => {
        const statKey = statMapping[stat] || stat.toLowerCase().replace(/\s/g, "");
        headers.push({ name: stat, key: statKey, sortable: true });
    });

    // Generate table headers with a "Sort by" button for threshold stats
    const tableHeaderRow = document.getElementById("tableHeaders");
    tableHeaderRow.innerHTML = headers.map(header => {
        if (header.sortable) {
            return `<th>${header.name} 
                        <button onclick="sortTableByStat('${header.key}')">Sort by ${header.name}</button>
                    </th>`;
        }
        return `<th>${header.name}</th>`;
    }).join("");

    // Add a "Sort by Combined Stats" button if two stats are available
    const combinedSortButton = document.getElementById("combinedStatsButton");
    if (Object.keys(thresholdData).length === 2) {
        combinedSortButton.style.display = "block";
        combinedSortButton.onclick = () => sortTableByCombinedStats(thresholdData);
    } else {
        combinedSortButton.style.display = "none"; // Hide button if not applicable
    }

    // Filter data to show only players whose teams are playing today
    const filteredDataForTeamsPlaying = data.filter(entry => {
        const playerTeam = projections.find(proj => proj.fixedPlayerName === entry.playerName)?.team;
        return teamsPlayingToday.includes(playerTeam);
    });

    // Display data with dynamic "Number of Uses" based on current playerUsages
    const tbody = document.querySelector("#csvTable tbody");
    tbody.innerHTML = ""; // Clear existing rows

    filteredDataForTeamsPlaying.forEach(entry => {
        const row = document.createElement("tr");
        row.setAttribute("data-player", entry.playerName); // Add player identifier for direct access

        const playerProjection = projections.find(proj => proj.fixedPlayerName === entry.playerName);
        const isInjured = playerProjection?.injuries === "Y" ? "Y" : ""; // Handle injuries as text

        if (isInjured) {
            row.classList.add("injured-player");
        }

        headers.forEach(header => {
            const cell = document.createElement("td");

            if (header.key === "playerName") {
                cell.textContent = entry.playerName;
            } else if (header.key === "tier") {
                cell.textContent = entry.tier;
            } else if (header.key === "uses") {
                cell.textContent = playerUsages[entry.playerName] || 0;
                cell.classList.add("usage-cell"); // Add class for easy access to usage cell
            } else if (header.key === "team") {
                cell.textContent = playerProjection?.team || "";
            } else if (header.key === "minutes") {
                cell.textContent = playerProjection?.minutes !== undefined ? parseFloat(playerProjection.minutes).toFixed(2) : "";
            } else if (header.key === "injuries") {
                cell.textContent = isInjured; // Display the injury status as text
            } else {
                const statKey = statMapping[header.name] || header.key;
                const value = playerProjection?.[statKey];
                cell.textContent = value !== undefined ? parseFloat(value).toFixed(2) : "";
            }

            row.appendChild(cell);
        });

        // Add the selection button as before
        const selectCell = document.createElement("td");
        const selectButton = document.createElement("button");
        selectButton.textContent = "Select";
        selectButton.onclick = () => {
            addPlayerToDay(selectedDay, entry.playerName);

            if (isInjured) {
                alert(`${entry.playerName} is currently injured.`);
            }
        };
        selectCell.appendChild(selectButton);
        row.appendChild(selectCell);

        tbody.appendChild(row);
    });

    if (!userTriggeredSort) {
        userTriggeredSort = false; // Reset only if auto-sorting was applied
    }
}



function sortTableByCombinedStats(thresholdData) {
    userTriggeredSort = true;  // Mark as user-initiated sort

    const [statKey1, statKey2] = Object.keys(thresholdData).map(stat => statMapping[stat] || stat.toLowerCase().replace(/\s/g, ""));

    window.filteredData = window.filteredData.sort((a, b) => {
        const playerProjA = projections.find(proj => proj.fixedPlayerName === a.playerName);
        const playerProjB = projections.find(proj => proj.fixedPlayerName === b.playerName);

        const valueA1 = playerProjA ? playerProjA[statKey1] || 0 : 0;
        const valueA2 = playerProjA ? playerProjA[statKey2] || 0 : 0;
        const valueB1 = playerProjB ? playerProjB[statKey1] || 0 : 0;
        const valueB2 = playerProjB ? playerProjB[statKey2] || 0 : 0;

        const combinedValueA = valueA1 + valueA2;
        const combinedValueB = valueB1 + valueB2;

        return combinedValueB - combinedValueA; // Descending order
    });

    console.log("Sorted Data by Combined Stats:", window.filteredData);

    // Refresh the table with the newly sorted data
    updateTableForSelectedDay(window.filteredData);
}


let sortState = {};

function sortTableByStat(statKey) {
    userTriggeredSort = true; // Set flag to indicate user-triggered sort

    // Toggle sorting order for the stat key
    const currentOrder = sortState[statKey] || 'asc';
    const newOrder = currentOrder === 'desc' ? 'asc' : 'desc';
    sortState[statKey] = newOrder;

    // Sort `filteredData` by the specified statKey
    window.filteredData = window.filteredData.sort((a, b) => {
        const playerProjA = projections.find(proj => proj.fixedPlayerName === a.playerName);
        const playerProjB = projections.find(proj => proj.fixedPlayerName === b.playerName);

        const valueA = playerProjA ? parseFloat(playerProjA[statKey]) || 0 : 0;
        const valueB = playerProjB ? parseFloat(playerProjB[statKey]) || 0 : 0;

        // Sort by the chosen order
        return newOrder === 'asc' ? valueA - valueB : valueB - valueA;
    });

    console.log(`Sorted data by stat: ${statKey} in ${newOrder} order`);

    // Refresh the table display after sorting
    updateTableForSelectedDay(window.filteredData);
}






function displayAllThresholds() {
    const allThresholdsDisplay = document.getElementById("allThresholdsDisplay");
    let tableContent = '<table border="1"><tr>';

    // Header row for days
    for (let i = 1; i <= 11; i++) {
        tableContent += `<th>Day ${i}</th>`;
    }
    tableContent += `</tr><tr>`;

    // Display each day's thresholds without inner tables
    for (let i = 1; i <= 11; i++) {
        const dayKey = `Day ${i}`;
        const thresholdData = thresholds[dayKey] || {};

        if (Object.keys(thresholdData).length === 2) {
            // If there are two stats, display one above the other
            const [stat1, stat2] = Object.keys(thresholdData);
            const [value1, value2] = Object.values(thresholdData);
            tableContent += `<td>
                                <div style="display: flex; flex-direction: column; align-items: center;">
                                    <div><strong>${stat1}</strong>: ${value1}</div>
                                    <div><strong>${stat2}</strong>: ${value2}</div>
                                </div>
                             </td>`;
        } else {
            // Single stat case
            const stat = Object.keys(thresholdData)[0] || 'No Stats';
            const value = Object.values(thresholdData)[0] || 'N/A';
            tableContent += `<td><div><strong>${stat}</strong>: ${value}</div></td>`;
        }
    }
    tableContent += `</tr></table>`;
    allThresholdsDisplay.innerHTML = tableContent;
}


function processTopShotData(csvData) {
    const rows = csvData.split("\n").slice(1);
    const playerData = {};

    rows.forEach(row => {
        const columns = row.split(",").map(cell => cell.replace(/^"|"$/g, "").trim());
        const playerName = columns[1];
        const tier = columns[5];

        // Only keep the highest tier for each player
        if (!playerData[playerName] || rarityOrder.indexOf(tier) < rarityOrder.indexOf(playerData[playerName].tier)) {
            const team = projections.find(proj => proj.fixedPlayerName === playerName)?.team || ""; // Map team info from projections
            const uses = usageMapping[tier] || 0; // Get allowed uses based on tier

            playerData[playerName] = {
                playerName,
                tier,
                team,  // Assign the team here
                uses // Assign the allowed uses based on rarity
            };
        }
    });

    // Filter to include only players found in the active roster
    const filteredData = Object.values(playerData).filter(entry => {
        return activeRoster.some(rosterEntry => 
            rosterEntry[1] === entry.playerName || rosterEntry[11] === entry.playerName
        );
    });

    // Sort by number of uses in descending order
    filteredData.sort((a, b) => (usageMapping[b.tier] || 0) - (usageMapping[a.tier] || 0));

    window.filteredData = filteredData;



    prepareAndDisplayData(filteredData);
    updateTableForSelectedDay(filteredData);
}



function prepareAndDisplayData(filteredData, selectedDay = null) {
    const dayKey = selectedDay ? `Day ${selectedDay}` : null;
    const thresholdData = dayKey && thresholds[dayKey] ? thresholds[dayKey] : null;

    const tbody = document.querySelector("#csvTable tbody");
    tbody.innerHTML = ""; // Clear existing rows

    // Define all columns, marking fixed ones to always display
    const headers = [
        { name: "Player Name", key: "playerName", alwaysVisible: true },
        { name: "Highest Tier", key: "tier", alwaysVisible: true },
        { name: "Number of Uses", key: "uses", alwaysVisible: true },
        { name: "Team", key: "team", alwaysVisible: true },
        { name: "Minutes", key: "minutes", alwaysVisible: true },
        { name: "Injuries", key: "injuries", alwaysVisible: true },
        { name: "Points", key: "points" },
        { name: "Assists", key: "assists" },
        { name: "Rebounds", key: "rebounds" },
        { name: "Steals", key: "steals" },
        { name: "Blocks", key: "blocks" },
        { name: "Turnovers", key: "turnovers" },
        { name: "Assists - Turnovers", key: "assists-turnovers" }, // New custom stat column
        { name: "Field Goals Made", key: "fieldGoalsMade" },
        { name: "Field Goals Attempted", key: "fieldGoalsAttempted" },
        { name: "3s", key: "threePointAttempts" },
        { name: "3s Attempted", key: "threePointAttempts" },
        { name: "Free Throws Made", key: "freeThrowsMade" },
        { name: "Free Throws Attempted", key: "freeThrowsAttempted" },
        { name: "Offensive Rebounds", key: "offensiveRebounds" },
        { name: "Defensive Rebounds", key: "defensiveRebounds" }
    ];

    // Determine which headers to display based on the selected day's thresholds
    const visibleHeaders = headers.filter(header => 
        header.alwaysVisible || (thresholdData && Object.keys(thresholdData).includes(header.name))
    );

    // Generate table headers
    const tableHeaderRow = document.getElementById("tableHeaders");
    tableHeaderRow.innerHTML = visibleHeaders.map(header => {
        if (!header.alwaysVisible) {
            // Add sort buttons for dynamic threshold stats
            return `<th>${header.name}
                    <button onclick="sortTableByStat('${header.key}', 'asc', '${selectedDay}')">Sort by</button>
                </th>`;
        }
        return `<th>${header.name}</th>`;
    }).join("");

    filteredData.forEach(entry => {
        const row = document.createElement("tr");

        // Find player projection once and store it
        const playerProjection = projections.find(proj => proj.fixedPlayerName === entry.playerName);
        const isInjured = playerProjection?.injuries === "Y";

        if (isInjured) {
            row.classList.add("injured-player");
        }

        visibleHeaders.forEach(header => {
            const cell = document.createElement("td");

            if (header.key === "playerName") {
                cell.textContent = entry.playerName;
            } else if (header.key === "tier") {
                cell.textContent = entry.tier;
            } else if (header.key === "uses") {
                cell.textContent = usageMapping[entry.tier] || 0;
            } else if (header.key === "team") {
                cell.textContent = playerProjection?.team || "";
            } else if (header.key === "minutes") {
                cell.textContent = playerProjection?.minutes !== undefined ? parseFloat(playerProjection.minutes).toFixed(2) : "";
            } else if (header.key === "injuries") {
                cell.textContent = playerProjection?.injuries || ""; // Display the injury status
            } else {
                const statKey = statMapping[header.name] || header.key;
                const value = playerProjection?.[statKey];
                cell.textContent = value !== undefined ? parseFloat(value).toFixed(2) : "";
            }

            cell.classList.add("stat-cell", `stat-${header.name.toLowerCase().replace(/\s/g, '')}`);
            row.appendChild(cell);
        });

        // Add player selection button with injury check
        const selectCell = document.createElement("td");
        const selectButton = document.createElement("button");
        selectButton.textContent = "Select";
        selectButton.onclick = () => {
            const day = document.getElementById("daySelect").value;
            addPlayerToDay(day, entry.playerName);

            // Show injury warning if applicable
            if (playerProjection?.injuries === "Y") {
                alert(`${entry.playerName} is currently injured.`);
            }
        };
        selectCell.appendChild(selectButton);
        row.appendChild(selectCell);


        tbody.appendChild(row);
    });
}


async function optimizeLineup() {

    const loadingOptimization = document.getElementById("loadingOptimization");
    loadingOptimization.style.display = "block"; // Show loading message

    try {
        const allGamesData = await fetchNBAGamesData();
        const allThresholds = await fetchThresholdsData();

        let playerUsage = {}; // Track player usage across all days
        const selectedPlayers = {}; // Store the optimized lineup for each day

        for (let day = 1; day <= 11; day++) {
            const dayKey = `Day ${day}`;
            const thresholds = allThresholds[dayKey];
            const teamsPlaying = allGamesData[dayKey] || [];

            // Get eligible players for this day
            const eligiblePlayers = window.filteredData.filter(player => 
                teamsPlaying.includes(player.team) &&
                (playerUsage[player.playerName] || 0) < player.uses
            );

            // Find the best lineup for the day
            const { lineup, meetsThresholds } = findOptimalLineupForDay(
                eligiblePlayers, 
                thresholds, 
                playerUsage
            );

            // Save the optimized lineup for the day
            selectedPlayers[day] = lineup.map(player => player.playerName);

            // Update player usage counts
            lineup.forEach(player => {
                playerUsage[player.playerName] = (playerUsage[player.playerName] || 0) + 1;
            });
        }

        // Update the selectedPlayersTable display
        updateSelectedPlayersDisplay(selectedPlayers);
    } catch (error) {
        console.error("Error optimizing lineup:", error);
    } finally {
        loadingOptimization.style.display = "none"; // Hide loading message
    }
}





function findOptimalLineupForDay(eligiblePlayers, thresholds, playerUsage) {
    const lineup = [];
    let currentTotals = {};

    // Initialize current totals to 0 for each threshold stat
    Object.keys(thresholds).forEach(stat => {
        currentTotals[stat] = 0;
    });

    while (lineup.length < 5) {
        let bestPlayer = null;
        let bestScore = -Infinity;

        // Evaluate players based on their contribution to unmet thresholds
        for (const player of eligiblePlayers) {
            const playerScore = calculateBalanceScoreForPlayer(player, thresholds, currentTotals);

            if (playerScore > bestScore) {
                bestScore = playerScore;
                bestPlayer = player;
            }
        }

        if (!bestPlayer) {
            // No players left who can contribute; stop adding players
            break;
        }

        // Add the best player to the lineup
        lineup.push(bestPlayer);

        // Update current totals with the selected player's stats
        Object.keys(thresholds).forEach(stat => {
            const statKey = statMapping[stat] || stat.toLowerCase().replace(/\s/g, "");
            const playerStat = getPlayerStat(bestPlayer, statKey) || 0;
            currentTotals[stat] += playerStat;

        });

        // Remove the selected player from eligible pool
        eligiblePlayers = eligiblePlayers.filter(p => p !== bestPlayer);
    }

    // Check if the lineup meets thresholds
    const meetsThresholds = Object.keys(thresholds).every(stat => {
        return currentTotals[stat] >= thresholds[stat];
    });

    return { lineup, meetsThresholds };
}


function calculateBalanceScoreForPlayer(player, thresholds, currentTotals) {
    let score = 0;

    Object.keys(thresholds).forEach(stat => {
        const statKey = statMapping[stat] || stat.toLowerCase().replace(/\s/g, "");
        const playerStat = getPlayerStat(player, statKey) || 0;

        const remainingGap = Math.max(thresholds[stat] - (currentTotals[stat] || 0), 0);
        const contributionRatio = remainingGap > 0 ? Math.min(playerStat / remainingGap, 1) : 0;

        score += contributionRatio; // Reward higher contributions to unmet thresholds
    });

    return score;
}





// Utility function to generate combinations of players
function generateCombinations(array, size) {
    const results = [];
    const recurse = (start, combination) => {
        if (combination.length === size) {
            results.push([...combination]);
            return;
        }
        for (let i = start; i < array.length; i++) {
            combination.push(array[i]);
            recurse(i + 1, combination);
            combination.pop();
        }
    };
    recurse(0, []);
    return results;
}





// Function to calculate cumulative stats for a lineup
function calculateLineupStats(lineup) {
    const lineupStats = {};

    lineup.forEach(player => {
        Object.keys(statMapping).forEach(stat => {
            const statKey = getMappedKey(stat);
            const playerStatValue = getPlayerStat(player, statKey) || 0;

            lineupStats[statKey] = (lineupStats[statKey] || 0) + playerStatValue;

        });
    });

    return lineupStats;
}



function evaluateLineup(lineup, thresholds) {
    let totalStats = {};
    let meetsThresholds = true;

    lineup.forEach(player => {
        Object.keys(thresholds).forEach(stat => {
            const statKey = statMapping[stat] || stat.toLowerCase().replace(/\s/g, "");
            totalStats[stat] = (totalStats[stat] || 0) + getPlayerStat(player, statKey) || 0;

            // Check if thresholds are met
            if (totalStats[stat] < thresholds[stat]) {
                meetsThresholds = false;
            }
        });
    });

    return { totalStats, meetsThresholds };
}




function getPlayerStat(player, stat) {
    const statKey = getMappedKey(stat);
    const playerProjection = projections.find(proj => proj.fixedPlayerName === player.playerName);
    
    if (playerProjection) {
        const statValue = playerProjection[statKey];
        return statValue !== undefined ? parseFloat(statValue) : 0;
    } else {
        return 0;
    }
}




    function displayOptimizedLineupResults(results) {
        const container = document.getElementById("optimizedLineupContainer");
        const resultsDiv = document.getElementById("optimizedLineupResults");
        resultsDiv.innerHTML = "";

        results.forEach(dayResult => {
            const dayDiv = document.createElement("div");
            dayDiv.innerHTML = `<h3>${dayResult.day}</h3><p>Thresholds: ${JSON.stringify(dayResult.thresholds)}</p>`;

            const playerList = document.createElement("ul");
            let totalStats = {};

            dayResult.players.forEach(player => {
                const playerItem = document.createElement("li");
                const playerStats = {};

                Object.keys(dayResult.thresholds).forEach(stat => {
                    const statKey = statMapping[stat] || stat.toLowerCase().replace(/\s/g, "");
                    const statValue = getPlayerStat(player, statKey) || 0;
                    playerStats[stat] = parseFloat(statValue).toFixed(2);

                    totalStats[stat] = parseFloat((parseFloat(totalStats[stat] || 0) + statValue).toFixed(2));
                });

                playerItem.textContent = `${player.playerName} - Stats: ${JSON.stringify(playerStats)}`;
                playerList.appendChild(playerItem);
            });

            Object.keys(totalStats).forEach(stat => {
                totalStats[stat] = parseFloat(totalStats[stat]).toFixed(2);
            });

            const totalStatsItem = document.createElement("p");
            totalStatsItem.textContent = `Total Stats for Day: ${JSON.stringify(totalStats)}`;
            dayDiv.appendChild(totalStatsItem);

            dayDiv.appendChild(playerList);
            resultsDiv.appendChild(dayDiv);
        });

        container.style.display = "block";
    }







// File processing function
async function processFiles() {
    const loadingCollection = document.getElementById("loadingCollection");
    loadingCollection.style.display = "block"; // Show loading message

    try {
        await fetchRosterData();
        await fetchProjectionsData();

        const topShotInput = document.getElementById('csvFileInput').files[0];
        if (!topShotInput) {
            alert("Please upload the NBA Top Shot CSV file.");
            loadingCollection.style.display = "none"; // Hide loading message
            return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
            processTopShotData(e.target.result); // Call processTopShotData directly
            initializePlayerUsages();
            loadingCollection.style.display = "none"; // Hide loading message after processing
        };
        reader.readAsText(topShotInput);
    } catch (error) {
        console.error("Error processing files:", error);
        loadingCollection.style.display = "none"; // Hide loading message in case of an error
    }
}


// Initialize page with default data
window.onload = async function() {
    const selectedDay = 1;
    await fetchThresholdsData();
    const gamesData = await fetchNBAGamesData(); // Fetch NBA games data
    await displayNBAGames(gamesData, selectedDay); // Display games for Day 1 on load
    initializeDaysHeaders(); // Set up day headers and clear buttons
    updateSelectedPlayersDisplay(); // Display selected players for all days
    updateTableForSelectedDay(window.filteredData);
};

</script>

</body>
</html>